# .NET 消息路由

## .Net Core的路由
1.  UseMvc中中MvcRouteHandler，MvcAttributeRouteHandler及自定义的IRoute加入到RouteBuilder中，RouteBuilder使用这些IRouter列表生成一个RouteCollection（也是IRouter对象），使用UseRouter将IRouter放到RouterMiddleware中间件中。

2. 当一个请求过来时，当RouterMiddleware通过调用RouteCollection集合的RouteAsync方法设置RouteContext的Handler（如果找到则返回），中间件如果发现有正确的Hander这调用Hander来处理，这时MvcRouteHandler，MvcAttributeRouteHandler里面Handler委托将执行。

3. MvcRouteHandler中的RouteAsync， 通过IActionSelector选择符合条件的Action列表，再从中选择最适合的Action（ActionDescriptor），而后使用ActionInvokerFactory获取IActionInvoker，最终由ActionInvoker调用InvokeAsync方法执行代码

4. MvcAttributeRouteHandler中的RouteAsync，通过IActionSelector直接从Actions中选择最适合的Action（ActionDescriptor），而后使用ActionInvokerFactory获取IActionInvoker，最终由ActionInvoker调用InvokeAsync方法执行代码

## .Net Framework的路由
1. 通过Application_Start中在RouteCollection中加入路由，Web Api在GlobalConfiguration中在创建使用RouteCollection作为HostedHttpRouteCollection(继承于HttpRouteCollection)，将IHttpRoute转化为HttpWebRoute加入到全局的RouteCollection集合中。

2. 当发生Http请求时，在Application的PostResolveRequestCache事件中，RouteData通过RouteCollection的GetRouteData方法返回正确的RouteData对象，具体来说是RouteValueDictionary选择最佳匹配的路由，而后根据RouteData的中的RouteHandler（默认情况下是一个）获取HttpHandler，设置到HttpContext中的当前HttpHandler，而后由HttpHandler做出请求的处理。

3. 对于MvcRouteHandler来说，他从RouteData中获取Controller Name, 并获取IControllerFactory传入MvcHandler(HttpHandler)中，在MvcHandler的ProcessRequest方法里，通过IControllerFactory创建Controller类，并执行Execute方法。在Controller的ExecuteCore方法中，获取ActionName，并调用ActionInvoker的InvokeAction方法来实现方法的执行, 默认有ControllerActionInvoker来执行。在执行时总返回一个ActionResult，并最终在ActionResult的ExecuteResult返回最终的响应


4. 对于Web Api来说，HttpControllerRouteHandler返回HttpControllerHandler, ASP.NET Web API 服务端框架采用管道式设计，
通过HttpControllerHandler 创建的。当HttpControllerHandler的BeginProcessRequest 方法被执行的时候,它会将请求分发给作为ASP.NET Web API 管道入口的HttpServer对象，紧随HttpServer 的是一系列HttpMessageHandler，它们按照排列的顺序对从HttpServer传递过来的请求作进一步处理，处理后请求被最终转发给HttpRoutingDispatcher,HttpControllerDispatcher，由它激活HttpController并执行目标Action方法。
